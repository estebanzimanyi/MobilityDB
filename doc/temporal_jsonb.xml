<?xml version="1.0" encoding="UTF-8"?>
<!--
   ****************************************************************************
    MobilityDB Manual
    Copyright(c) MobilityDB Contributors

    This documentation is licensed under a Creative Commons Attribution-Share
    Alike 3.0 License: https://creativecommons.org/licenses/by-sa/3.0/
   ****************************************************************************
-->
<chapter xml:id="temporal_jsonb">
	<title>Temporal JSON</title>

	<para>PostgreSQL provides two types for storing JSON data: <varname>json</varname> and <varname>jsonb</varname>. The <varname>json</varname> type stores an exact copy of the input text, which must be reparsed each time it is processed. On the other hand, the <varname>jsonb</varname> type stores the JSON data in a decomposed binary format that makes it slightly slower to input due to added conversion overhead, but significantly faster to process, since no reparsing is needed. The <varname>jsonb</varname> type also supports indexing.</para>

	<para>In MobilityDB, the <varname>ttext</varname> type serves for manipulating temporal JSON data. Furthermore, the <varname>jsonb</varname> type serves as base type for defining the temporal type <varname>tjsonb</varname>. Being a temporal type, most functions and operators described before for temporal types are also applicable for the <varname>tjsonb</varname> type. In addition, there are specific functions defined for the <varname>ttext</varname> and the <varname>tjsonb</varname> types, which are derived from the corresponding functions of the <varname>json</varname> and the <varname>jsonb</varname> types. We refer to the PostgreSQL <ulink url="https://www.postgresql.org/docs/current/datatype-json.html">documentation</ulink> for a detailed explanation of the <varname>json</varname> and <varname>jsonb</varname> types and their functionality.</para>

	<para>We describe next the <varname>tjsonb</varname> type and its associated operations. The corresponding operations for the <varname>ttext</varname> type are given in previous chapters. We also describe the generalization of the JSON functions for the <varname>ttext</varname> and <varname>tjsonb</varname> types.</para>

	<sect1 xml:id="temp_jsonb">
		<title>Temporal JSONB values</title>
		<para>The temporal type <varname>tjsonb</varname> allows to represent the evolution in time of <varname>jsonb</varname> values. As all temporal types, it comes in three subtypes, namely, instant, sequence, and sequence set. Examples of <varname>tjsonb</varname> values in these subtypes are given next.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
-- Instant
SELECT tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01';
-- Sequence with discrete interpolation
SELECT tjsonb '{{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02}';
-- Sequence with step interpolation
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]';
-- Sequence set
SELECT tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02],
  [{"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03,
  {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-04]}';
</programlisting>
		<para>As can be seen above, for the <varname>Instant</varname> subtype we need to enclose the JSONB value between quotes and escape the inner quotes, otherwise the opening brace of the JSONB value would be interpreted as the beginning of a <varname>Sequence</varname> subtype with discrete interpolation.</para>

		<para>The <varname>tjsonb</varname> type accepts type modifiers (or <varname>typmod</varname> in PostgreSQL terminology) to specify the subtype. The possible values for the subtype are <varname>Instant</varname>, <varname>Sequence</varname>, and <varname>SequenceSet</varname>. The argument is optional and if not specified for a column, values of any subtype are allowed.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb(Instant) '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01';
--  {"location": "Point(1 1)", "vehicleId": 1}@2001-01-01
SELECT tjsonb(Sequence) '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01';
-- ERROR: Temporal type (Instant) does not match column type (Sequence)
</programlisting>

		<para>Temporal JSONB values of sequence or sequence set subtype are converted into a normal form so that equivalent values have identical representations. For this, consecutive instant values are merged when possible. Three consecutive instant values can be merged into two if their JSONB values are equal. Also, two consecutive sequences that are adjacent and have the same end and start JSONB value can be merged into a single one. Examples of transformation into a normal form are as follows.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asText(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03] */
SELECT asText(tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03],
  ({"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-04]}');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02,
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-04]} */
</programlisting>
	</sect1>

	<sect1 xml:id="tjsonb_validity">
		<title>Validity of temporal JSONB values</title>

		<para>Temporal JSONB values must satisfy the constraints specified in <xref linkend="ttype_validity"/> so that they are well defined. An error is raised whenever one of these constraints are not satisfied. Examples of incorrect values are as follows.</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
-- Null values are not allowed
SELECT tjsonb 'NULL@2001-01-01 08:05:00';
SELECT tjsonb 'Point(0 0)@NULL';
-- Base type is not a JSONB
SELECT tjsonb 'Point(0 0)@2001-01-01 08:05:00';
</programlisting>
		<para>We give next the functions and operators for temporal JSONB. Most functions and operators for temporal types described in the previous chapters can be applied for temporal JSONB types. Therefore, in the signatures of the functions given previously, the notation <varname>base</varname> represents a <varname>jsonb</varname> value and the notation <varname>ttype</varname>, represents a <varname>tjsonb</varname> value. To avoid redundancy, we only present next some examples of these functions and operators for temporal JSONB values.</para>
	</sect1>

	<sect1 xml:id="tjsonb_inout">
		<title>Input and Output</title>

		<itemizedlist>
			<listitem xml:id="tjsonb_asText">
				<indexterm significance="normal"><primary><varname>asText</varname></primary></indexterm>
				<para>Return the Well-Known Text (WKT) representation</para>
				<para><varname>asText({tjsonb,tjsonb[]}) → {text,text[]}</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asText(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02] */
SELECT asText(ARRAY[tjsonb '"{\"vehicleId\":1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  '"{\"vehicleId\": 1, \"location\": \"Point(2 2)\"}"@2001-01-02']);
/* {"{\"location\": \"Point(1 1)\", \"vehicleId\": 1}@2001-01-01",
   "{\"location\": \"Point(2 2)\", \"vehicleId\": 1}@2001-01-02"} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_asBinary">
				<indexterm significance="normal"><primary><varname>asBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>asHexWKB</varname></primary></indexterm>
				<para>Return the Well-Known Binary (WKB) or the Hexadecimal Extended Well-Known Binary (HexWKB) representation</para>
				<para><varname>asBinary(tjsonb,endian text='') → bytea</varname></para>
				<para><varname>asHexWKB(tjsonb,endian text='') → text</varname></para>
				<para>The result is encoded using either the little-endian (NDR) or the big-endian (XDR) encoding. If no encoding is specified, then the encoding of the machine is used.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asBinary(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 2)\"}"@2001-01-01');
-- \x0141000138000000000000000200002008000080090000000a000000090000106c6f636174696f6e7...
SELECT asHexWKB(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 2)\"}"@2001-01-01');
-- 0141000138000000000000000200002008000080090000000A000000090000106C6F636174696F6E7...
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_asMFJSON">
				<indexterm significance="normal"><primary><varname>asMFJSON</varname></primary></indexterm>
				<para>Return the Moving Features JSON (MF-JSON) representation</para>
				<para><varname>asMFJSON(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT asMFJSON(tjsonb '[{"Position": "Point(1 1)"}@2001-01-01,
  {"Position": "Point(2 2)"}@2001-01-02]');
/* {"type":"MovingJsonb","values":[{"Position": "Point(1 1)"},{"Position": "Point(2 2)"}],
   "datetimes":["2001-01-01T00:00:00+01","2001-01-02T00:00:00+01"],
   "lower_inc":true,"upper_inc":true,"interpolation":"Step"} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbFromText">
				<indexterm significance="normal"><primary><varname>tjsonbFromText</varname></primary></indexterm>
				<para>Input from the Well-Known Text (WKT) representation</para>
				<para><varname>tjsonbFromText(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbFromText(text
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
   {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02] */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbFromBinary">
				<indexterm significance="normal"><primary><varname>tjsonbFromBinary</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonbFromHexWKB</varname></primary></indexterm>
				<para>Input from the Well-Known Binary (WKB) or from the Hexadecimal Well-Known Binary (HexWKB) representation</para>
				<para><varname>tjsonbFromBinary(bytea) → tjsonb</varname></para>
				<para><varname>tjsonbFromHexWKB(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbFromBinary(asBinary(
  tjsonb '[{"vehicleId": 1, "location": "Point(1 2)"}@2001-01-01]'));
-- [{"location": "Point(1 2)", "vehicleId": 1}@2001-01-01]
SELECT tjsonbFromHexWKB(asHexWKB(
  tjsonb '[{"vehicleId": 1, "location": "Point(1 2)"}@2001-01-01]'));
-- [{"location": "Point(1 2)", "vehicleId": 1}@2001-01-01]
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbFromMFJSON">
				<indexterm significance="normal"><primary><varname>tjsonbFromMFJSON</varname></primary></indexterm>
				<para>Input from the Moving Features JSON (MF-JSON) representation</para>
				<para><varname>tjsonbFromMFJSON(text) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbFromMFJSON('{"type": "MovingJSON", "interpolation": "Step",
  "values": [{"Position": "Point(1 1)"}, {"Position": "Point(2 2)"}],
  "datetimes": ["2001-01-01T10:00:00Z","2001-01-01T12:00:00Z"]}');
/* [{"Position": "Point(1 1)"}@2001-01-01 11:00:00+01,
   {"Position": "Point(2 2)"}@2001-01-01 13:00:00+01] */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_constructors">
		<title>Constructors</title>

		<itemizedlist>
			<listitem xml:id="tjsonb_const">
				<indexterm significance="normal"><primary><varname>tjsonb</varname></primary></indexterm>
				<para>Constructor for temporal JSONB values having a constant value</para>
				<para><varname>tjsonb(jsonb,timestamptz) → tjsonbInst</varname></para>
				<para><varname>tjsonb(jsonb,tstzset) → tjsonbDiscSeq</varname></para>
				<para><varname>tjsonb(jsonb,tstzspan) → tjsonbContSeq</varname></para>
				<para><varname>tjsonb(jsonb,tstzspanset) → tjsonbSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}', timestamptz '2001-01-01');
-- {"location": "Point(1 1)", "vehicleId": 1}@2001-01-01
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}',
  tstzset '{2001-01-01, 2001-01-03, 2001-01-05}');
/* {{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-05} */
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}',
  tstzspan '[2001-01-01, 2001-01-02]');
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02] */
SELECT tjsonb('{"vehicleId": 1, "location": "Point(1 1)"}',
  tstzspanset '{[2001-01-01, 2001-01-02],[2001-01-03, 2001-01-04]}');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
     {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02],
    [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-03,
     {"location": "Point(1 1)", "vehicleId": 1}@2001-01-04]} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbSeq">
				<indexterm significance="normal"><primary><varname>tjsonbSeq</varname></primary></indexterm>
				<para>Constructor for temporal JSONB values of sequence subtype</para>
				<para><varname>tjsonbSeq(tjsonbInst[]},leftInc bool=true,rightInc bool=true) →tjsonbSeq</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbSeq(ARRAY[tjsonb
  '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  '"{\"vehicleId\": 1, \"location\": \"Point(2 2)\"}"@2001-01-02',
  '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-03']);
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03] */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonbSeqSet">
				<indexterm significance="normal"><primary><varname>tjsonbSeqSet</varname></primary></indexterm>
				<para>Constructor for temporal JSONB values of sequence set subtype</para>
				<para><varname>tjsonbSeqset(tjsonb[]) → tjsonbSeqSet</varname></para>
				<para><varname>tjsonbSeqSetGaps(tjsonbInst[],maxt=NULL,maxdist=NULL) → tjsonbSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbSeqSet(ARRAY[tjsonb
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]',
  '[{"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03,
    {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-04]']);
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02],
   [{"location": "Point(2 2)", "vehicleId": 1}@2001-01-03,
    {"location": "Point(3 3)", "vehicleId": 1}@2001-01-04} */
SELECT tjsonbSeqSetGaps(ARRAY[tjsonb
  '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  '"{\"vehicleId\": 1, \"location\": \"Point(2 2)\"}"@2001-01-03',
  '"{\"vehicleId\": 1, \"location\": \"Point(3 3)\"}"@2001-01-05'], interval '1 day');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01],
    [{"location": "Point(2 2)", "vehicleId": 1}@2001-01-03],
    [{"location": "Point(3 3)", "vehicleId": 1}@2001-01-05]} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_conversions">
		<title>Conversions</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_tstzspan">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convert a temporal JSONB to a <varname>tstzspan</varname></para>
				<para><varname>tjsonb::tstzpan</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]'::tstzspan;
-- [2001-01-01, 2001-01-02]
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_text">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convert between a temporal JSONB and a text</para>
				<para><varname>tjsonb::text</varname></para>
				<para><varname>text::tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT (text '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]')::jsonb;
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02] */
SELECT pg_typeof(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]'::text);
-- text
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_ttext">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Convert between a temporal JSONB and a temporal text</para>
				<para><varname>tjsonb::ttext</varname></para>
				<para><varname>ttext::tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT (ttext '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]')::tjsonb;
/* [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(2 2)", "vehicleId": 1}@2001-01-02] */
SELECT pg_typeof(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]'::ttext);
-- ttext
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_accessors">
		<title>Accessors</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_getValues">
				<indexterm significance="normal"><primary><varname>getValues</varname></primary></indexterm>
				<para>Return the values</para>
				<para><varname>getValues(tjsonb) → jsonbset</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT getValues(tjsonb
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]');
-- {{"location": "Point(1 1)", "vehicleId": 1}}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_valueAtTimestamp">
				<indexterm significance="normal"><primary><varname>valueAtTimestamp</varname></primary></indexterm>
				<para>Return the value at a timestamp</para>
				<para><varname>valueAtTimestamp(tjsonb,timestamptz) → jsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT valueAtTimestamp(tjsonb
  '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]', '2001-01-02');
-- {"location": "Point(2 2)", "vehicleId": 1}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_transformations">
		<title>Transformations</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_subtype">
				<indexterm significance="normal"><primary><varname>tjsonbInst</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonbSeq</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonbSeqSet</varname></primary></indexterm>
				<para>Transform a temporal JSONB to another subtype</para>
				<para><varname>tjsonbInst(tjsonb) → tjsonbInst</varname></para>
				<para><varname>tjsonbSeq(tjsonb,interp='step') → tjsonbSeq</varname></para>
				<para><varname>tjsonbSeqSet(tjsonb) → tjsonbSeqSet</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonbSeq(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01');
-- [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01]
SELECT tjsonbSeq(tjsonb '"{\"vehicleId\": 1, \"location\": \"Point(1 1)\"}"@2001-01-01',
  'discrete');
-- {{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01}
SELECT tjsonbSeqSet(tjsonb '"{\"vehicleId\": 1,\"location\":\"Point(1 1)\"}"@2001-01-01');
-- {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_setInterp">
				<indexterm significance="normal"><primary><varname>setInterp</varname></primary></indexterm>
				<para>Transform a temporal JSONB value to another interpolation</para>
				<para><varname>setInterp(tjsonb, interp) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT setInterp(tjsonb '"{\"vehicleId\": 1,\"location\": \"Point(1 1)\"}"@2001-01-01','step');
-- [{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01]
SELECT setInterp(tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01],
  [{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02]}', 'discrete');
/* {{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-02} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_jsonb">
		<title>Temporal JSON Operations</title>
		<para>The following functions are temporal versions of the corresponding functions for the <varname>json</varname> and <varname>jsonb</varname> types. We refer to the PostgreSQL <ulink url="https://www.postgresql.org/docs/current/functions-json.html">documentation</ulink> for detailed explanations of these functions.</para>

		<itemizedlist>
			<listitem xml:id="tjson_object_field">
				<indexterm significance="normal"><primary><varname>-></varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>->></varname></primary></indexterm>
				<para>Extract a temporal JSON object field specified by a key</para>
				<para><varname>{ttext,tjsonb} -> text → {ttext,tjsonb}</varname></para>
				<para><varname>{ttext,tjsonb} ->> text → ttext</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT ttext '{[{"unit": "km", "speed": 10}@2001-01-01, 
  {"unit": "km", "speed": 20}@2001-01-02]}' -> text 'speed';
-- {["10"@2001-01-01, "20"@2001-01-02]}
SELECT tjsonb '[{"position":"Point(1 1)", "speed":10}@2001-01-01, 
  {"position":"Point(2 2)", "speed":20}@2001-01-03]' ->> text 'position';
-- ["Point(1 1)"@2001-01-01, "Point(2 2)"@2001-01-03]
</programlisting>
			</listitem>

			<listitem xml:id="tjson_extract_path">
				<indexterm significance="normal"><primary><varname>-></varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>->></varname></primary></indexterm>
				<para>Extract a temporal JSON object field specified by a path</para>
				<para><varname>{ttext,tjsonb} #> text[] → {ttext,tjsonb}</varname></para>
				<para><varname>{ttext,tjsonb} #>> text[] → ttext</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT ttext '[{"speed": {"unit": "km", "value": 10}}@2001-01-01, 
  {"speed": {"unit": "km", "value": 20}}@2001-01-02]' #> ARRAY[text 'speed', 'value'];
-- {["10"@2001-01-01, "20"@2001-01-02]}
SELECT tjsonb '[{"position":"Point(1 1)", "PoIs":["Grand Place", "La Bourse"]}@2001-01-01, 
  {"position":"Point(2 2)", "PoIs":["Palais Royal", "Manneken Pis"]}@2001-01-03]' #>>
  ARRAY[text 'PoIs', '1'];
-- ["La Bourse"@2001-01-01, "Manneken Pis"@2001-01-03]
</programlisting>
			</listitem>

			<listitem xml:id="tjson_array_element">
				<indexterm significance="normal"><primary><varname>tjson_array_element</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonb_array_element</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonb_array_element_text</varname></primary></indexterm>
				<para>Extract an element from a temporal JSON array</para>
				<para><varname>tjson_array_element(tjsonb,integer) → tjsonb</varname></para>
				<para><varname>tjsonb_array_element(tjsonb,integer) → tjsonb</varname></para>
				<para><varname>tjsonb_array_element_text(tjsonb,integer) → tjsonb</varname></para>
				<para>The given index must exist in <emphasis>every</emphasis> instant of the temporal JSONB value, otherwise an error is returned.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjson_array_element(ttext '[["Grand Place", "La Bourse"]@2001-01-01,
  ["Palais Royal", "Manneken Pis"]@2001-01-02]', 0);
-- ["Grand Place"@2001-01-01 00:00:00+01, "Palais Royal"@2001-01-02 00:00:00+01]
SELECT tjsonb_array_element(tjsonb '[["Grand Place", "La Bourse"]@2001-01-01,
  ["Palais Royal", "Manneken Pis"]@2001-01-02]', 1);
-- ["La Bourse"@2001-01-01, "Manneken Pis"@2001-01-02]
SELECT tjsonb_array_element(tjsonb '[["Grand Place", "La Bourse"]@2001-01-01,
  ["Palais Royal"]@2001-01-02]', 1);
-- NULL
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_talphanum">
				<indexterm significance="normal"><primary><varname>tbool</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tint</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tfloat</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>ttext</varname></primary></indexterm>
				<para>Extract a temporal alphanumeric value from a temporal JSONB value given by a key</para>
				<para><varname>tbool(tjsonb,text) → tbool</varname></para>
				<para><varname>tint(tjsonb,text) → tint</varname></para>
				<para><varname>tfloat(tjsonb,text,interp='linear') → tfloat</varname></para>
				<para><varname>ttext(tjsonb,text) → ttext</varname></para>
				<para>The given key must exist in <emphasis>every</emphasis> instant of the temporal JSONB value, otherwise an error is returned.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tbool(tjsonb '[{"speed": 10, "lights": "on"}@2001-01-01,
  {"speed": 20, "lights": "on"}@2001-01-02]', 'lights');
-- [true@2001-01-01, true@2001-01-02]
SELECT tint(tjsonb '[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"speed": 20, "units": "km/h"}@2001-01-02]', 'speed');
-- [10@2001-01-01, 20@2001-01-02]
SELECT tfloat(tjsonb '{[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"speed": 20, "units": "km/h"}@2001-01-02],[{"speed": 20}@2001-01-03,
  {"speed": 20}@2001-01-04]}', 'speed', 'step');
-- Interp=Step;{[10@2001-01-01, 20@2001-01-02], [20@2001-01-03, 20@2001-01-04]}
SELECT ttext(tjsonb '[{"road": "Bvd Gén. Jacques", "category": "primary"}@2001-01-01,
  {"road": "Bvd Gén. Jacques", "category": "primary"}@2001-01-02,
  {"road": "Bvd de la Cambre", "category": "residential"}@2001-01-03]', 'category');
-- [primary@2001-01-01, residential@2001-01-03]
SELECT tint(tjsonb '[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"units": "km/h"}@2001-01-02]', 'speed');
-- JSON key "speed" not found
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_concat">
				<indexterm significance="normal"><primary><varname>||</varname></primary></indexterm>
				<para>Temporal JSONB concatenation</para>
				<para><varname>tjsonb || {jsonb,tjsonb} → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '{[{"speed":10}@2001-01-01, {"speed":20}@2001-01-02]}' ||
  '{"unit":"km"}'::jsonb;
-- {[{"unit": "km", "speed": 10}@2001-01-01, {"unit": "km", "speed": 20}@2001-01-02]}
SELECT tjsonb '{[{"speed":10}@2001-01-01, {"speed":20}@2001-01-03]}' ||
  tjsonb '{[{"Position":"Point(1 1)"}@2001-01-02, {"Position":"Point(2 2)"}@2001-01-04]}';
/* {[{"speed": 10, "Position": "Point(1 1)"}@2001-01-02,
     {"speed": 20, "Position": "Point(2 2)"}@2001-01-03]} */
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_delete">
				<indexterm significance="normal"><primary><varname>-</varname></primary></indexterm>
				<para>Temporal JSONB deletion</para>
				<para><varname>{jsonb,tjsonb} - {jsonb,tjsonb} → tjsonb</varname></para>
				<para><varname>tjsonb - {int,int[],text,text[]} → tjsonb</varname></para>
				<para>The function return NULL as soon as one resulting JSONB value is empty, that is, is equal to '{}'.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '{[{"unit": "km", "speed": 10}@2001-01-01,
  {"unit": "km", "speed": 20}@2001-01-02]}' - 'unit';
-- {[{"speed": 10}@2001-01-01, {"speed": 20}@2001-01-02]}
SELECT tjsonb '{[{"unit": "km", "speed": 10}@2001-01-01,
  {"unit": "km", "speed": 20}@2001-01-02]}' - ARRAY[text 'unit', 'speed'];
-- NULL
SELECT tjsonb '[["Grand Place", "La Bourse"]@2001-01-01,
  ["Palais Royal", "Manneken Pis"]@2001-01-02]' - 1;
-- [["Grand Place"]@2001-01-01, ["Palais Royal"]@2001-01-02]
SELECT tjsonb '[["Grand Place", "La Bourse"]@2001-01-01,
  ["Palais Royal"]@2001-01-02]' - 0;
-- NULL
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_exists">
				<indexterm significance="normal"><primary><varname>?</varname></primary></indexterm>
				<para>Temporal JSONB exists</para>
				<para><varname>tjsonb ? jsonb → tbool</varname></para>
				<para><varname>tjsonb ?| jsonb[] → tbool</varname></para>
				<para><varname>tjsonb ?&amp; jsonb[] → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '"{\"geom\": \"Point(1 1)\"}"@2001-01-01' ? text 'geom';
-- t@2001-01-01
SELECT tjsonb '{{"geom": "Point(1 1)"}@2001-01-01, {"geom": "Point(2 2)"}@2001-01-02,
  {"geom": "Point(1 1)"}@2001-01-03}' ?| ARRAY[text 'geom'];
-- {t@2001-01-01, t@2001-01-02, t@2001-01-03}
SELECT tjsonb '[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"speed": 20, "units": "km/h"}@2001-01-02]' ?&amp; ARRAY['speed', 'units'];
-- {[t@2001-01-01, t@2001-01-02]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_contains">
				<indexterm significance="normal"><primary><varname>@&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;@</varname></primary></indexterm>
				<para>Temporal JSONB contains/contained</para>
				<para><varname>{tjsonb,jsonb} @&gt; {tjsonb,jsonb} → tbool</varname></para>
				<para><varname>{tjsonb,jsonb} &lt;@ {tjsonb,jsonb} → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '"{\"geom\": \"Point(1 1)\"}"@2001-01-01' @&gt; jsonb '{"geom": "Point(1 1)"}';
-- t@2001-01-01
SELECT tjsonb '{{"geom": "Point(1 1)"}@2001-01-01, {"geom": "Point(2 2)"}@2001-01-02,
  {"geom": "Point(1 1)"}@2001-01-03}' @&gt; jsonb '{"geom": "Point(1 1)"}';
-- {t@2001-01-01, f@2001-01-02, t@2001-01-03}
SELECT jsonb '{"geom": "Point(1 1)"}' &lt;@ tjsonb '{[{"geom": "Point(1 1)"}@2001-01-01,
  {"geom": "Point(1 1)"}@2001-01-02, {"geom": "Point(1 1)"}@2001-01-03],
  [{"geom": "Point(2 2)"}@2001-01-04, {"geom": "Point(2 2)"}@2001-01-05]}';
-- {[t@2001-01-01, t@2001-01-03], [f@2001-01-04, f@2001-01-05]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_set">
				<indexterm significance="normal"><primary><varname>tjsonb_set</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonb_set_lax</varname></primary></indexterm>
				<para>Temporal JSONB set</para>
				<para><varname>tjsonb_set(tjsonb,path text[],jsonb,create boolean=true) → tjsonb</varname></para>
				<para><varname>tjsonb_set_lax(tjsonb,path text[],jsonb,create boolean=true,handle_null text) → tjsonb</varname></para>
				<para>Return the <varname>tjsonb</varname> value with the item specified by path replaced by <varname>jsonb</varname>, or added if <varname>create</varname> is true and the item does not exist. All earlier steps in the path must exist, or the target is returned unchanged. As with the path oriented operators, negative integers that appear in the path count from the end of JSON arrays. If the last path step is an array index that is out of range, and create_if_missing is true, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.
        </para>
				<para>Function <varname>tjsonb_set_lax</varname> behaves identically to <varname>tjsonb_set</varname> if the given value is not NULL, Otherwise, it behaves according to the value of <varname>handle_null</varname>, which must be one of <varname>'raise_exception'</varname>, <varname>'use_json_null'</varname>, <varname>'delete_key'</varname>, or <varname>'return_target'</varname>.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb_set(tjsonb '[{"speed":10}@2001-01-01, {"speed":20}@2001-01-02]',
  ARRAY['units'], '"km/h"'::jsonb);
-- [{"speed": 10, "units": "km/h"}@2001-01-01, {"speed": 20, "units": "km/h"}@2001-01-02]
SELECT tjsonb_set(tjsonb '[{"speed":10}@2001-01-01, {"speed":20}@2001-01-02]',
  ARRAY['units'], '"km/h"'::jsonb, false);
-- [{"speed": 10}@2001-01-01, {"speed": 20}@2001-01-02]
SELECT tjsonb_set(tjsonb '[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"speed": 20, "units": "km/h"}@2001-01-02]', ARRAY['units'], '"mi/h"'::jsonb);
-- [{"speed": 10, "units": "mi/h"}@2001-01-01, {"speed": 20, "units": "mi/h"}@2001-01-02]
SELECT tjsonb_set_lax(tjsonb '[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"speed": 20}@2001-01-02]', ARRAY['units'], 'null'::jsonb, true, 'return_target');
-- [{"speed": 10, "units": "km/h"}@2001-01-01, {"speed": 20}@2001-01-02]
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_insert">
				<indexterm significance="normal"><primary><varname>tjsonb_insert</varname></primary></indexterm>
				<para>Temporal JSONB insert</para>
				<para><varname>tjsonb_insert(tjsonb,path text[],jsonb,after boolean=false) → tjsonb</varname></para>
				<para>Return the <varname>tjsonb</varname> value with <varname>jsonb</varname> inserted. If the item specified by the path is an array element, the new value will be inserted before that item if <varname>after</varname> is false, or after it otherwise. If the item specified by the path is an object field, the new value will be inserted only if the object does not already contain that key. All earlier steps in the path must exist, or the target is returned unchanged. As with the path oriented operators, negative integers that appear in the path count from the end of JSON arrays. If the last path step is an array index that is out of range, the new value is added at the beginning of the array if the index is negative, or at the end of the array if it is positive.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb_insert(tjsonb '[{"speed":10}@2001-01-01, {"speed":20}@2001-01-02]',
  ARRAY['units'], '"km/h"'::jsonb);
-- [{"speed": 10, "units": "km/h"}@2001-01-01, {"speed": 20, "units": "km/h"}@2001-01-02]
SELECT tjsonb_insert(tjsonb '[{"speed":10}@2001-01-01, {"speed":20}@2001-01-02]',
  ARRAY['units'], '"km/h"'::jsonb, false);
-- [{"speed": 10}@2001-01-01, {"speed": 20}@2001-01-02]
SELECT tjsonb_insert(tjsonb '[{"speed": 10, "units": "km/h"}@2001-01-01,
  {"speed": 20, "units": "km/h"}@2001-01-02]', ARRAY['units'], '"mi/h"'::jsonb);
-- [{"speed": 10, "units": "mi/h"}@2001-01-01, {"speed": 20, "units": "mi/h"}@2001-01-02]
</programlisting>
			</listitem>

			<listitem xml:id="tjson_strip_nulls">
				<indexterm significance="normal"><primary><varname>tjson_strip_nulls</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>tjsonb_strip_nulls</varname></primary></indexterm>
				<para>Return a temporal JSON value without nulls</para>
				<para><varname>tjson_strip_nulls(ttext, strip_in_arrays bool=false) → ttext</varname></para>
				<para><varname>tjsonb_strip_nulls(tjsonb, strip_in_arrays bool=false) → tjsonb</varname></para>
				<para>The last argument states whether null array elements are also stripped. Bare null values are never stripped.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjson_strip_nulls(ttext '[{"speed": 10, "lights": null}@2001-01-01,
  {"speed": 20, "PoIs": ["Grand Place", "La Bourse", null]}@2001-01-02]');
/* [{"speed": 10}@2001-01-01,
   {"PoIs": ["Grand Place", "La Bourse", null], "speed": 20}@2001-01-02] */
SELECT tjsonb_strip_nulls(tjsonb '[{"speed": 10, "lights": null}@2001-01-01,
  {"speed": 20, "PoIs": ["Grand Place", "La Bourse", null]}@2001-01-02]', true);
/* [{"speed": 10}@2001-01-01,
   {"PoIs": ["Grand Place", "La Bourse"], "speed": 20}@2001-01-02] */
SELECT tjsonb_strip_nulls(tjsonb
  '{{"road": "Bvd Gén. Jacques", "category": "primary"}@2001-01-01,
  {"road": "Bvd de la Cambre", "category": "primary"}@2001-01-02,
  {"road": "rue de l''Abbaye", "category": null}@2001-01-03}');
/* [{"road": "Bvd Gén. Jacques", "category": "primary"}@2001-01-01, 
   {"road": "Bvd de la Cambre", "category": "primary"}@2001-01-02,
   {"road": "rue de l'Abbaye"}@2001-01-03] */
</programlisting>
			</listitem>

		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_restrictions">
		<title>Restrictions</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_atValues">
				<indexterm significance="normal"><primary><varname>atValues</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>minusValues</varname></primary></indexterm>
				<para>Restrict to (the complement of) a set of values</para>
				<para><varname>atValues(tjsonb,values) → tjsonb</varname></para>
				<para><varname>minusValues(tjsonb,values) → tjsonb</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT atValues(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]',
  jsonb '{"vehicleId": 1, "location": "Point(2 2)"}');
-- {[{"location": "Point(2 2)", "vehicleId": 1}@2001-01-03]}
SELECT minusValues(tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]',
  jsonb '{"vehicleId": 1, "location": "Point(2 2)"}');
/* {[{"location": "Point(1 1)", "vehicleId": 1}@2001-01-01,
    {"location": "Point(1 1)", "vehicleId": 1}@2001-01-03)} */
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_comparisons">
		<title>Comparisons</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_comp">
				<indexterm significance="normal"><primary><varname>=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&gt;=</varname></primary></indexterm>
				<para>Traditional comparisons</para>
				<para><varname>tjsonb {=, &lt;&gt;, &lt;, &gt;, &lt;=, &gt;=} tjsonb → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02),
  [{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
   {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]}' =
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]';
-- true
SELECT tjsonb '{[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]}' &lt;&gt;
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]';
-- false
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]' &lt;
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_ever_always">
				<indexterm significance="normal"><primary><varname>?=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>%=</varname></primary></indexterm>
				<para>Ever and always comparisons</para>
				<para><varname>{jsonb,tjsonb} {?=, %=} {jsonb,tjsonb} → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' ?=
  jsonb '{"vehicleId": 1, "location": "Point(1 1)"}';
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' %=
  jsonb '{"vehicleId": 1, "location": "Point(1 1)"}';
-- false
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_tcomp">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Temporal comparisons</para>
				<para><varname>{jsonb,tjsonb} {#=, #&lt;&gt;} {jsonb,tjsonb} → tbool</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03)' #=
  jsonb '{"vehicleId": 1, "location": "Point(1 1)"}';
-- {[f@2001-01-01, t@2001-01-02], (f@2001-01-02, f@2001-01-03)}
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03)' #&lt;&gt;
  tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
  {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03)';
-- {[t@2001-01-01, f@2001-01-02], (t@2001-01-02, t@2001-01-03)}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_bbox_ops">
		<title>Bounding Box Operations</title>
		<itemizedlist>
			<listitem xml:id="tjsonb_topo">
				<indexterm significance="normal"><primary><varname>&amp;&amp;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>&lt;@</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>@&gt;</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>~=</varname></primary></indexterm>
				<indexterm significance="normal"><primary><varname>-|-</varname></primary></indexterm>
				<para>Topological operators</para>
				<para><varname>{tjsonb,tstzspan} {&amp;&amp;, &lt;@#, #@&gt;, ~=, -|-} {tjsonb,tstzspan} → boolean</varname></para>
				<para>The temporal contains and contained operator are marked with a <varname>#</varname> to distinguish them from the corresponding JSONB operators.</para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' &amp;&amp;
  tstzspan '[2001-01-01, 2001-03-01]';
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' #@&gt;
  timestamptz '[2001-01-02]'::tstzspan;
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' -|-
  tjsonb '({"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02,
    {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-03]';
-- true
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_pos">
				<indexterm significance="normal"><primary><varname>::</varname></primary></indexterm>
				<para>Position operators</para>
				<para><varname>{tjsonb,tstzspan} {&lt;&lt;#, &amp;&lt;#, #&gt;&gt;, #&amp;&gt;} {tjsonb,tstzspan} → boolean</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-02]' &lt;&lt;#
  tstzspan '[2001-01-01, 2001-03-01]';
-- false
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]' #&gt;&gt;
  timestamptz '[2001-01-01]'::tstzspan;
-- true
SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
    {"vehicleId": 1, "location": "Point(2 2)"}@2001-01-03]' #&amp;&gt;
  tjsonb '[{"vehicleId": 1, "location": "Point(2 2)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(3 3)"}@2001-01-03]';
-- true
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_aggregations">
		<title>Aggregations</title>
		<para>The aggregate functions for temporal JSONB values are illustrated next.</para>

		<itemizedlist>
			<listitem xml:id="tjsonb_tCount">
				<indexterm significance="normal"><primary><varname>tCount</varname></primary></indexterm>
				<para>Temporal count</para>
				<para><varname>tCount(tjsonb) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
WITH Temp(temp) AS (
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]' UNION
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-04]' )
SELECT tCount(Temp)
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 2@2001-01-03], (1@2001-01-03, 1@2001-01-04]}
</programlisting>
			</listitem>

			<listitem xml:id="tjsonb_wCount">
				<indexterm significance="normal"><primary><varname>wCount</varname></primary></indexterm>
				<para>Window count</para>
				<para><varname>wCount(tjsonb) → {tintSeq,tintSeqSet}</varname></para>
				<programlisting language="sql" xml:space="preserve" format="linespecific">
WITH Temp(temp) AS (
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-01,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-03]' UNION
  SELECT tjsonb '[{"vehicleId": 1, "location": "Point(1 1)"}@2001-01-02,
    {"vehicleId": 1, "location": "Point(1 1)"}@2001-01-04]' )
SELECT wCount(Temp, interval '2 days')
FROM Temp;
-- {[1@2001-01-01, 2@2001-01-02, 2@2001-01-05], (1@2001-01-05, 1@2001-01-06]}
</programlisting>
			</listitem>
		</itemizedlist>
	</sect1>

	<sect1 xml:id="tjsonb_indexing">
		<title>Indexing</title>

		<para>GiST and SP-GiST indexes can be created for table columns of temporal JSONB values. An example of index creation is follows:</para>
		<programlisting language="sql" xml:space="preserve" format="linespecific">
CREATE INDEX Trips_Trip_SPGist_Idx ON Trips USING SPGist(Trip);
</programlisting>
		<para>The GiST and SP-GiST indexes store the bounding box for the temporal JSONB values, which is an <varname>stbox</varname>, as all spatiotemporal types.</para>

		<para>A GiST or SP-GiST index can accelerate queries involving the following operators:</para>
		<itemizedlist>
			<listitem>
				<para><varname>&lt;&lt;</varname>, <varname>&amp;&lt;</varname>, <varname>&amp;&gt;</varname>, <varname>&gt;&gt;</varname>, <varname>&lt;&lt;|</varname>, <varname>&amp;&lt;|</varname>, <varname>|&amp;&gt;</varname>, <varname>|&gt;&gt;</varname>, which only consider the spatial dimension in temporal JSONB values,</para>
			</listitem>
			<listitem>
				<para><varname>&lt;&lt;#</varname>, <varname>&amp;&lt;#</varname>, <varname>#&amp;&gt;</varname>, <varname>#&gt;&gt;</varname>, which only consider the time dimension in temporal JSONB values,</para>
			</listitem>
			<listitem>
				<para><varname>&amp;&amp;</varname>, <varname>@&gt;</varname>, <varname>&lt;@</varname>, <varname>~=</varname>, <varname>-|-</varname>, and <varname>|=|</varname> , which consider as many dimensions as they are shared by the indexed column and the query argument.</para>
			</listitem>
		</itemizedlist>
		<para>These operators work on bounding boxes, not the entire values.</para>
	</sect1>
</chapter>

