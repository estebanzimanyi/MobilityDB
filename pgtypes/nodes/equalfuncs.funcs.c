/*-------------------------------------------------------------------------
 *
 * equalfuncs.funcs.c
 *    Generated node infrastructure code
 *
 * Portions Copyright (c) 1996-2025, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * NOTES
 *  ******************************
 *  *** DO NOT EDIT THIS FILE! ***
 *  ******************************
 *
 *  It has been GENERATED by src/backend/nodes/gen_node_support.pl
 *
 *-------------------------------------------------------------------------
 */
// #include "access/amapi.h"
// #include "access/cmptype.h"
// #include "access/sdir.h"
// #include "access/tableam.h"
// #include "access/tsmapi.h"
// #include "commands/event_trigger.h"
// #include "commands/trigger.h"
// #include "executor/tuptable.h"
// #include "foreign/fdwapi.h"
// #include "nodes/bitmapset.h"
// #include "nodes/execnodes.h"
// #include "nodes/extensible.h"
// #include "nodes/lockoptions.h"
// #include "nodes/miscnodes.h"
#include "nodes/nodes.h"
#include "nodes/parsenodes.h"
#include "nodes/pathnodes.h"
// #include "nodes/plannodes.h"
#include "nodes/primnodes.h"
// #include "nodes/replnodes.h"
// #include "nodes/supportnodes.h"
#include "nodes/value.h"
// #include "utils/rel.h"

static bool
_equalAlias(const Alias *a, const Alias *b)
{
  COMPARE_STRING_FIELD(aliasname);
  COMPARE_NODE_FIELD(colnames);

  return true;
}

static bool
_equalRangeVar(const RangeVar *a, const RangeVar *b)
{
  COMPARE_STRING_FIELD(catalogname);
  COMPARE_STRING_FIELD(schemaname);
  COMPARE_STRING_FIELD(relname);
  COMPARE_SCALAR_FIELD(inh);
  COMPARE_SCALAR_FIELD(relpersistence);
  COMPARE_NODE_FIELD(alias);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalParam(const Param *a, const Param *b)
{
  COMPARE_SCALAR_FIELD(paramkind);
  COMPARE_SCALAR_FIELD(paramid);
  COMPARE_SCALAR_FIELD(paramtype);
  COMPARE_SCALAR_FIELD(paramtypmod);
  COMPARE_SCALAR_FIELD(paramcollid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalAggref(const Aggref *a, const Aggref *b)
{
  COMPARE_SCALAR_FIELD(aggfnoid);
  COMPARE_SCALAR_FIELD(aggtype);
  COMPARE_SCALAR_FIELD(aggcollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(aggargtypes);
  COMPARE_NODE_FIELD(aggdirectargs);
  COMPARE_NODE_FIELD(args);
  COMPARE_NODE_FIELD(aggorder);
  COMPARE_NODE_FIELD(aggdistinct);
  COMPARE_NODE_FIELD(aggfilter);
  COMPARE_SCALAR_FIELD(aggstar);
  COMPARE_SCALAR_FIELD(aggvariadic);
  COMPARE_SCALAR_FIELD(aggkind);
  COMPARE_SCALAR_FIELD(agglevelsup);
  COMPARE_SCALAR_FIELD(aggsplit);
  COMPARE_SCALAR_FIELD(aggno);
  COMPARE_SCALAR_FIELD(aggtransno);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalGroupingFunc(const GroupingFunc *a, const GroupingFunc *b)
{
  COMPARE_NODE_FIELD(args);
  COMPARE_SCALAR_FIELD(agglevelsup);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalWindowFunc(const WindowFunc *a, const WindowFunc *b)
{
  COMPARE_SCALAR_FIELD(winfnoid);
  COMPARE_SCALAR_FIELD(wintype);
  COMPARE_SCALAR_FIELD(wincollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_NODE_FIELD(aggfilter);
  COMPARE_NODE_FIELD(runCondition);
  COMPARE_SCALAR_FIELD(winref);
  COMPARE_SCALAR_FIELD(winstar);
  COMPARE_SCALAR_FIELD(winagg);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalWindowFuncRunCondition(const WindowFuncRunCondition *a, const WindowFuncRunCondition *b)
{
  COMPARE_SCALAR_FIELD(opno);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_SCALAR_FIELD(wfunc_left);
  COMPARE_NODE_FIELD(arg);

  return true;
}

static bool
_equalMergeSupportFunc(const MergeSupportFunc *a, const MergeSupportFunc *b)
{
  COMPARE_SCALAR_FIELD(msftype);
  COMPARE_SCALAR_FIELD(msfcollid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalSubscriptingRef(const SubscriptingRef *a, const SubscriptingRef *b)
{
  COMPARE_SCALAR_FIELD(refcontainertype);
  COMPARE_SCALAR_FIELD(refelemtype);
  COMPARE_SCALAR_FIELD(refrestype);
  COMPARE_SCALAR_FIELD(reftypmod);
  COMPARE_SCALAR_FIELD(refcollid);
  COMPARE_NODE_FIELD(refupperindexpr);
  COMPARE_NODE_FIELD(reflowerindexpr);
  COMPARE_NODE_FIELD(refexpr);
  COMPARE_NODE_FIELD(refassgnexpr);

  return true;
}

static bool
_equalFuncExpr(const FuncExpr *a, const FuncExpr *b)
{
  COMPARE_SCALAR_FIELD(funcid);
  COMPARE_SCALAR_FIELD(funcresulttype);
  COMPARE_SCALAR_FIELD(funcretset);
  COMPARE_SCALAR_FIELD(funcvariadic);
  COMPARE_SCALAR_FIELD(funccollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalNamedArgExpr(const NamedArgExpr *a, const NamedArgExpr *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_STRING_FIELD(name);
  COMPARE_SCALAR_FIELD(argnumber);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalOpExpr(const OpExpr *a, const OpExpr *b)
{
  COMPARE_SCALAR_FIELD(opno);
  if (a->opfuncid != b->opfuncid && a->opfuncid != 0 && b->opfuncid != 0)
    return false;
  COMPARE_SCALAR_FIELD(opresulttype);
  COMPARE_SCALAR_FIELD(opretset);
  COMPARE_SCALAR_FIELD(opcollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalDistinctExpr(const DistinctExpr *a, const DistinctExpr *b)
{
  COMPARE_SCALAR_FIELD(opno);
  if (a->opfuncid != b->opfuncid && a->opfuncid != 0 && b->opfuncid != 0)
    return false;
  COMPARE_SCALAR_FIELD(opresulttype);
  COMPARE_SCALAR_FIELD(opretset);
  COMPARE_SCALAR_FIELD(opcollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalNullIfExpr(const NullIfExpr *a, const NullIfExpr *b)
{
  COMPARE_SCALAR_FIELD(opno);
  if (a->opfuncid != b->opfuncid && a->opfuncid != 0 && b->opfuncid != 0)
    return false;
  COMPARE_SCALAR_FIELD(opresulttype);
  COMPARE_SCALAR_FIELD(opretset);
  COMPARE_SCALAR_FIELD(opcollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalScalarArrayOpExpr(const ScalarArrayOpExpr *a, const ScalarArrayOpExpr *b)
{
  COMPARE_SCALAR_FIELD(opno);
  if (a->opfuncid != b->opfuncid && a->opfuncid != 0 && b->opfuncid != 0)
    return false;
  if (a->hashfuncid != b->hashfuncid && a->hashfuncid != 0 && b->hashfuncid != 0)
    return false;
  if (a->negfuncid != b->negfuncid && a->negfuncid != 0 && b->negfuncid != 0)
    return false;
  COMPARE_SCALAR_FIELD(useOr);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalBoolExpr(const BoolExpr *a, const BoolExpr *b)
{
  COMPARE_SCALAR_FIELD(boolop);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalSubLink(const SubLink *a, const SubLink *b)
{
  COMPARE_SCALAR_FIELD(subLinkType);
  COMPARE_SCALAR_FIELD(subLinkId);
  COMPARE_NODE_FIELD(testexpr);
  COMPARE_NODE_FIELD(operName);
  COMPARE_NODE_FIELD(subselect);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalSubPlan(const SubPlan *a, const SubPlan *b)
{
  COMPARE_SCALAR_FIELD(subLinkType);
  COMPARE_NODE_FIELD(testexpr);
  COMPARE_NODE_FIELD(paramIds);
  COMPARE_SCALAR_FIELD(plan_id);
  COMPARE_STRING_FIELD(plan_name);
  COMPARE_SCALAR_FIELD(firstColType);
  COMPARE_SCALAR_FIELD(firstColTypmod);
  COMPARE_SCALAR_FIELD(firstColCollation);
  COMPARE_SCALAR_FIELD(useHashTable);
  COMPARE_SCALAR_FIELD(unknownEqFalse);
  COMPARE_SCALAR_FIELD(parallel_safe);
  COMPARE_NODE_FIELD(setParam);
  COMPARE_NODE_FIELD(parParam);
  COMPARE_NODE_FIELD(args);
  COMPARE_SCALAR_FIELD(startup_cost);
  COMPARE_SCALAR_FIELD(per_call_cost);

  return true;
}

static bool
_equalAlternativeSubPlan(const AlternativeSubPlan *a, const AlternativeSubPlan *b)
{
  COMPARE_NODE_FIELD(subplans);

  return true;
}

static bool
_equalFieldSelect(const FieldSelect *a, const FieldSelect *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(fieldnum);
  COMPARE_SCALAR_FIELD(resulttype);
  COMPARE_SCALAR_FIELD(resulttypmod);
  COMPARE_SCALAR_FIELD(resultcollid);

  return true;
}

static bool
_equalFieldStore(const FieldStore *a, const FieldStore *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_NODE_FIELD(newvals);
  COMPARE_NODE_FIELD(fieldnums);
  COMPARE_SCALAR_FIELD(resulttype);

  return true;
}

static bool
_equalRelabelType(const RelabelType *a, const RelabelType *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(resulttype);
  COMPARE_SCALAR_FIELD(resulttypmod);
  COMPARE_SCALAR_FIELD(resultcollid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCoerceViaIO(const CoerceViaIO *a, const CoerceViaIO *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(resulttype);
  COMPARE_SCALAR_FIELD(resultcollid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalArrayCoerceExpr(const ArrayCoerceExpr *a, const ArrayCoerceExpr *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_NODE_FIELD(elemexpr);
  COMPARE_SCALAR_FIELD(resulttype);
  COMPARE_SCALAR_FIELD(resulttypmod);
  COMPARE_SCALAR_FIELD(resultcollid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalConvertRowtypeExpr(const ConvertRowtypeExpr *a, const ConvertRowtypeExpr *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(resulttype);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCollateExpr(const CollateExpr *a, const CollateExpr *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(collOid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCaseExpr(const CaseExpr *a, const CaseExpr *b)
{
  COMPARE_SCALAR_FIELD(casetype);
  COMPARE_SCALAR_FIELD(casecollid);
  COMPARE_NODE_FIELD(arg);
  COMPARE_NODE_FIELD(args);
  COMPARE_NODE_FIELD(defresult);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCaseWhen(const CaseWhen *a, const CaseWhen *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_NODE_FIELD(result);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCaseTestExpr(const CaseTestExpr *a, const CaseTestExpr *b)
{
  COMPARE_SCALAR_FIELD(typeId);
  COMPARE_SCALAR_FIELD(typeMod);
  COMPARE_SCALAR_FIELD(collation);

  return true;
}

static bool
_equalArrayExpr(const ArrayExpr *a, const ArrayExpr *b)
{
  COMPARE_SCALAR_FIELD(array_typeid);
  COMPARE_SCALAR_FIELD(array_collid);
  COMPARE_SCALAR_FIELD(element_typeid);
  COMPARE_NODE_FIELD(elements);
  COMPARE_SCALAR_FIELD(multidims);
  COMPARE_LOCATION_FIELD(list_start);
  COMPARE_LOCATION_FIELD(list_end);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalRowExpr(const RowExpr *a, const RowExpr *b)
{
  COMPARE_NODE_FIELD(args);
  COMPARE_SCALAR_FIELD(row_typeid);
  COMPARE_NODE_FIELD(colnames);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalRowCompareExpr(const RowCompareExpr *a, const RowCompareExpr *b)
{
  COMPARE_SCALAR_FIELD(cmptype);
  COMPARE_NODE_FIELD(opnos);
  COMPARE_NODE_FIELD(opfamilies);
  COMPARE_NODE_FIELD(inputcollids);
  COMPARE_NODE_FIELD(largs);
  COMPARE_NODE_FIELD(rargs);

  return true;
}

static bool
_equalCoalesceExpr(const CoalesceExpr *a, const CoalesceExpr *b)
{
  COMPARE_SCALAR_FIELD(coalescetype);
  COMPARE_SCALAR_FIELD(coalescecollid);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalMinMaxExpr(const MinMaxExpr *a, const MinMaxExpr *b)
{
  COMPARE_SCALAR_FIELD(minmaxtype);
  COMPARE_SCALAR_FIELD(minmaxcollid);
  COMPARE_SCALAR_FIELD(inputcollid);
  COMPARE_SCALAR_FIELD(op);
  COMPARE_NODE_FIELD(args);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalSQLValueFunction(const SQLValueFunction *a, const SQLValueFunction *b)
{
  COMPARE_SCALAR_FIELD(op);
  COMPARE_SCALAR_FIELD(type);
  COMPARE_SCALAR_FIELD(typmod);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalXmlExpr(const XmlExpr *a, const XmlExpr *b)
{
  COMPARE_SCALAR_FIELD(op);
  COMPARE_STRING_FIELD(name);
  COMPARE_NODE_FIELD(named_args);
  COMPARE_NODE_FIELD(arg_names);
  COMPARE_NODE_FIELD(args);
  COMPARE_SCALAR_FIELD(xmloption);
  COMPARE_SCALAR_FIELD(indent);
  COMPARE_SCALAR_FIELD(type);
  COMPARE_SCALAR_FIELD(typmod);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonFormat(const JsonFormat *a, const JsonFormat *b)
{
  COMPARE_SCALAR_FIELD(format_type);
  COMPARE_SCALAR_FIELD(encoding);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonReturning(const JsonReturning *a, const JsonReturning *b)
{
  COMPARE_NODE_FIELD(format);
  COMPARE_SCALAR_FIELD(typid);
  COMPARE_SCALAR_FIELD(typmod);

  return true;
}

static bool
_equalJsonValueExpr(const JsonValueExpr *a, const JsonValueExpr *b)
{
  COMPARE_NODE_FIELD(raw_expr);
  COMPARE_NODE_FIELD(formatted_expr);
  COMPARE_NODE_FIELD(format);

  return true;
}

static bool
_equalJsonConstructorExpr(const JsonConstructorExpr *a, const JsonConstructorExpr *b)
{
  COMPARE_SCALAR_FIELD(type);
  COMPARE_NODE_FIELD(args);
  COMPARE_NODE_FIELD(func);
  COMPARE_NODE_FIELD(coercion);
  COMPARE_NODE_FIELD(returning);
  COMPARE_SCALAR_FIELD(absent_on_null);
  COMPARE_SCALAR_FIELD(unique);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonIsPredicate(const JsonIsPredicate *a, const JsonIsPredicate *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_NODE_FIELD(format);
  COMPARE_SCALAR_FIELD(item_type);
  COMPARE_SCALAR_FIELD(unique_keys);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonBehavior(const JsonBehavior *a, const JsonBehavior *b)
{
  COMPARE_SCALAR_FIELD(btype);
  COMPARE_NODE_FIELD(expr);
  COMPARE_SCALAR_FIELD(coerce);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonExpr(const JsonExpr *a, const JsonExpr *b)
{
  COMPARE_SCALAR_FIELD(op);
  COMPARE_STRING_FIELD(column_name);
  COMPARE_NODE_FIELD(formatted_expr);
  COMPARE_NODE_FIELD(format);
  COMPARE_NODE_FIELD(path_spec);
  COMPARE_NODE_FIELD(returning);
  COMPARE_NODE_FIELD(passing_names);
  COMPARE_NODE_FIELD(passing_values);
  COMPARE_NODE_FIELD(on_empty);
  COMPARE_NODE_FIELD(on_error);
  COMPARE_SCALAR_FIELD(use_io_coercion);
  COMPARE_SCALAR_FIELD(use_json_coercion);
  COMPARE_SCALAR_FIELD(wrapper);
  COMPARE_SCALAR_FIELD(omit_quotes);
  COMPARE_SCALAR_FIELD(collation);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonTablePath(const JsonTablePath *a, const JsonTablePath *b)
{
  COMPARE_NODE_FIELD(value);
  COMPARE_STRING_FIELD(name);

  return true;
}

static bool
_equalJsonTablePathScan(const JsonTablePathScan *a, const JsonTablePathScan *b)
{
  COMPARE_NODE_FIELD(path);
  COMPARE_SCALAR_FIELD(errorOnError);
  COMPARE_NODE_FIELD(child);
  COMPARE_SCALAR_FIELD(colMin);
  COMPARE_SCALAR_FIELD(colMax);

  return true;
}

static bool
_equalJsonTableSiblingJoin(const JsonTableSiblingJoin *a, const JsonTableSiblingJoin *b)
{
  COMPARE_NODE_FIELD(lplan);
  COMPARE_NODE_FIELD(rplan);

  return true;
}

static bool
_equalNullTest(const NullTest *a, const NullTest *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(nulltesttype);
  COMPARE_SCALAR_FIELD(argisrow);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalBooleanTest(const BooleanTest *a, const BooleanTest *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(booltesttype);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalMergeAction(const MergeAction *a, const MergeAction *b)
{
  COMPARE_SCALAR_FIELD(matchKind);
  COMPARE_SCALAR_FIELD(commandType);
  COMPARE_SCALAR_FIELD(override);
  COMPARE_NODE_FIELD(qual);
  COMPARE_NODE_FIELD(targetList);
  COMPARE_NODE_FIELD(updateColnos);

  return true;
}

static bool
_equalCoerceToDomain(const CoerceToDomain *a, const CoerceToDomain *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(resulttype);
  COMPARE_SCALAR_FIELD(resulttypmod);
  COMPARE_SCALAR_FIELD(resultcollid);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCoerceToDomainValue(const CoerceToDomainValue *a, const CoerceToDomainValue *b)
{
  COMPARE_SCALAR_FIELD(typeId);
  COMPARE_SCALAR_FIELD(typeMod);
  COMPARE_SCALAR_FIELD(collation);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalSetToDefault(const SetToDefault *a, const SetToDefault *b)
{
  COMPARE_SCALAR_FIELD(typeId);
  COMPARE_SCALAR_FIELD(typeMod);
  COMPARE_SCALAR_FIELD(collation);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCurrentOfExpr(const CurrentOfExpr *a, const CurrentOfExpr *b)
{
  COMPARE_SCALAR_FIELD(cvarno);
  COMPARE_STRING_FIELD(cursor_name);
  COMPARE_SCALAR_FIELD(cursor_param);

  return true;
}

static bool
_equalNextValueExpr(const NextValueExpr *a, const NextValueExpr *b)
{
  COMPARE_SCALAR_FIELD(seqid);
  COMPARE_SCALAR_FIELD(typeId);

  return true;
}

static bool
_equalInferenceElem(const InferenceElem *a, const InferenceElem *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_SCALAR_FIELD(infercollid);
  COMPARE_SCALAR_FIELD(inferopclass);

  return true;
}

static bool
_equalReturningExpr(const ReturningExpr *a, const ReturningExpr *b)
{
  COMPARE_SCALAR_FIELD(retlevelsup);
  COMPARE_SCALAR_FIELD(retold);
  COMPARE_NODE_FIELD(retexpr);

  return true;
}

static bool
_equalTargetEntry(const TargetEntry *a, const TargetEntry *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_SCALAR_FIELD(resno);
  COMPARE_STRING_FIELD(resname);
  COMPARE_SCALAR_FIELD(ressortgroupref);
  COMPARE_SCALAR_FIELD(resorigtbl);
  COMPARE_SCALAR_FIELD(resorigcol);
  COMPARE_SCALAR_FIELD(resjunk);

  return true;
}

static bool
_equalRangeTblRef(const RangeTblRef *a, const RangeTblRef *b)
{
  COMPARE_SCALAR_FIELD(rtindex);

  return true;
}

static bool
_equalJoinExpr(const JoinExpr *a, const JoinExpr *b)
{
  COMPARE_SCALAR_FIELD(jointype);
  COMPARE_SCALAR_FIELD(isNatural);
  COMPARE_NODE_FIELD(larg);
  COMPARE_NODE_FIELD(rarg);
  COMPARE_NODE_FIELD(usingClause);
  COMPARE_NODE_FIELD(join_using_alias);
  COMPARE_NODE_FIELD(quals);
  COMPARE_NODE_FIELD(alias);
  COMPARE_SCALAR_FIELD(rtindex);

  return true;
}

static bool
_equalFromExpr(const FromExpr *a, const FromExpr *b)
{
  COMPARE_NODE_FIELD(fromlist);
  COMPARE_NODE_FIELD(quals);

  return true;
}

static bool
_equalOnConflictExpr(const OnConflictExpr *a, const OnConflictExpr *b)
{
  COMPARE_SCALAR_FIELD(action);
  COMPARE_NODE_FIELD(arbiterElems);
  COMPARE_NODE_FIELD(arbiterWhere);
  COMPARE_SCALAR_FIELD(constraint);
  COMPARE_NODE_FIELD(onConflictSet);
  COMPARE_NODE_FIELD(onConflictWhere);
  COMPARE_SCALAR_FIELD(exclRelIndex);
  COMPARE_NODE_FIELD(exclRelTlist);

  return true;
}

static bool
_equalQuery(const Query *a, const Query *b)
{
  COMPARE_SCALAR_FIELD(commandType);
  COMPARE_SCALAR_FIELD(querySource);
  COMPARE_SCALAR_FIELD(canSetTag);
  COMPARE_NODE_FIELD(utilityStmt);
  COMPARE_SCALAR_FIELD(resultRelation);
  COMPARE_SCALAR_FIELD(hasAggs);
  COMPARE_SCALAR_FIELD(hasWindowFuncs);
  COMPARE_SCALAR_FIELD(hasTargetSRFs);
  COMPARE_SCALAR_FIELD(hasSubLinks);
  COMPARE_SCALAR_FIELD(hasDistinctOn);
  COMPARE_SCALAR_FIELD(hasRecursive);
  COMPARE_SCALAR_FIELD(hasModifyingCTE);
  COMPARE_SCALAR_FIELD(hasForUpdate);
  COMPARE_SCALAR_FIELD(hasRowSecurity);
  COMPARE_SCALAR_FIELD(hasGroupRTE);
  COMPARE_SCALAR_FIELD(isReturn);
  COMPARE_NODE_FIELD(cteList);
  COMPARE_NODE_FIELD(rtable);
  COMPARE_NODE_FIELD(rteperminfos);
  COMPARE_NODE_FIELD(jointree);
  COMPARE_NODE_FIELD(mergeActionList);
  COMPARE_SCALAR_FIELD(mergeTargetRelation);
  COMPARE_NODE_FIELD(mergeJoinCondition);
  COMPARE_NODE_FIELD(targetList);
  COMPARE_SCALAR_FIELD(override);
  COMPARE_NODE_FIELD(onConflict);
  COMPARE_STRING_FIELD(returningOldAlias);
  COMPARE_STRING_FIELD(returningNewAlias);
  COMPARE_NODE_FIELD(returningList);
  COMPARE_NODE_FIELD(groupClause);
  COMPARE_SCALAR_FIELD(groupDistinct);
  COMPARE_NODE_FIELD(groupingSets);
  COMPARE_NODE_FIELD(havingQual);
  COMPARE_NODE_FIELD(windowClause);
  COMPARE_NODE_FIELD(distinctClause);
  COMPARE_NODE_FIELD(sortClause);
  COMPARE_NODE_FIELD(limitOffset);
  COMPARE_NODE_FIELD(limitCount);
  COMPARE_SCALAR_FIELD(limitOption);
  COMPARE_NODE_FIELD(rowMarks);
  COMPARE_NODE_FIELD(setOperations);
  COMPARE_NODE_FIELD(constraintDeps);
  COMPARE_NODE_FIELD(withCheckOptions);
  COMPARE_LOCATION_FIELD(stmt_location);
  COMPARE_LOCATION_FIELD(stmt_len);

  return true;
}

static bool
_equalTypeName(const TypeName *a, const TypeName *b)
{
  COMPARE_NODE_FIELD(names);
  COMPARE_SCALAR_FIELD(typeOid);
  COMPARE_SCALAR_FIELD(setof);
  COMPARE_SCALAR_FIELD(pct_type);
  COMPARE_NODE_FIELD(typmods);
  COMPARE_SCALAR_FIELD(typemod);
  COMPARE_NODE_FIELD(arrayBounds);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalColumnRef(const ColumnRef *a, const ColumnRef *b)
{
  COMPARE_NODE_FIELD(fields);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalParamRef(const ParamRef *a, const ParamRef *b)
{
  COMPARE_SCALAR_FIELD(number);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalA_Expr(const A_Expr *a, const A_Expr *b)
{
  COMPARE_SCALAR_FIELD(kind);
  COMPARE_NODE_FIELD(name);
  COMPARE_NODE_FIELD(lexpr);
  COMPARE_NODE_FIELD(rexpr);
  COMPARE_LOCATION_FIELD(rexpr_list_start);
  COMPARE_LOCATION_FIELD(rexpr_list_end);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalTypeCast(const TypeCast *a, const TypeCast *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_NODE_FIELD(typeName);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalCollateClause(const CollateClause *a, const CollateClause *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_NODE_FIELD(collname);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalRoleSpec(const RoleSpec *a, const RoleSpec *b)
{
  COMPARE_SCALAR_FIELD(roletype);
  COMPARE_STRING_FIELD(rolename);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalFuncCall(const FuncCall *a, const FuncCall *b)
{
  COMPARE_NODE_FIELD(funcname);
  COMPARE_NODE_FIELD(args);
  COMPARE_NODE_FIELD(agg_order);
  COMPARE_NODE_FIELD(agg_filter);
  COMPARE_NODE_FIELD(over);
  COMPARE_SCALAR_FIELD(agg_within_group);
  COMPARE_SCALAR_FIELD(agg_star);
  COMPARE_SCALAR_FIELD(agg_distinct);
  COMPARE_SCALAR_FIELD(func_variadic);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalA_Star(const A_Star *a UNUSED, const A_Star *b UNUSED)
{
  return true;
}

static bool
_equalA_Indices(const A_Indices *a, const A_Indices *b)
{
  COMPARE_SCALAR_FIELD(is_slice);
  COMPARE_NODE_FIELD(lidx);
  COMPARE_NODE_FIELD(uidx);

  return true;
}

static bool
_equalA_Indirection(const A_Indirection *a, const A_Indirection *b)
{
  COMPARE_NODE_FIELD(arg);
  COMPARE_NODE_FIELD(indirection);

  return true;
}

static bool
_equalA_ArrayExpr(const A_ArrayExpr *a, const A_ArrayExpr *b)
{
  COMPARE_NODE_FIELD(elements);
  COMPARE_LOCATION_FIELD(list_start);
  COMPARE_LOCATION_FIELD(list_end);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalResTarget(const ResTarget *a, const ResTarget *b)
{
  COMPARE_STRING_FIELD(name);
  COMPARE_NODE_FIELD(indirection);
  COMPARE_NODE_FIELD(val);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalMultiAssignRef(const MultiAssignRef *a, const MultiAssignRef *b)
{
  COMPARE_NODE_FIELD(source);
  COMPARE_SCALAR_FIELD(colno);
  COMPARE_SCALAR_FIELD(ncolumns);

  return true;
}

static bool
_equalSortBy(const SortBy *a, const SortBy *b)
{
  COMPARE_NODE_FIELD(node);
  COMPARE_SCALAR_FIELD(sortby_dir);
  COMPARE_SCALAR_FIELD(sortby_nulls);
  COMPARE_NODE_FIELD(useOp);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalWindowDef(const WindowDef *a, const WindowDef *b)
{
  COMPARE_STRING_FIELD(name);
  COMPARE_STRING_FIELD(refname);
  COMPARE_NODE_FIELD(partitionClause);
  COMPARE_NODE_FIELD(orderClause);
  COMPARE_SCALAR_FIELD(frameOptions);
  COMPARE_NODE_FIELD(startOffset);
  COMPARE_NODE_FIELD(endOffset);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalRangeSubselect(const RangeSubselect *a, const RangeSubselect *b)
{
  COMPARE_SCALAR_FIELD(lateral);
  COMPARE_NODE_FIELD(subquery);
  COMPARE_NODE_FIELD(alias);

  return true;
}

static bool
_equalRangeFunction(const RangeFunction *a, const RangeFunction *b)
{
  COMPARE_SCALAR_FIELD(lateral);
  COMPARE_SCALAR_FIELD(ordinality);
  COMPARE_SCALAR_FIELD(is_rowsfrom);
  COMPARE_NODE_FIELD(functions);
  COMPARE_NODE_FIELD(alias);
  COMPARE_NODE_FIELD(coldeflist);

  return true;
}

static bool
_equalRangeTableFunc(const RangeTableFunc *a, const RangeTableFunc *b)
{
  COMPARE_SCALAR_FIELD(lateral);
  COMPARE_NODE_FIELD(docexpr);
  COMPARE_NODE_FIELD(rowexpr);
  COMPARE_NODE_FIELD(namespaces);
  COMPARE_NODE_FIELD(columns);
  COMPARE_NODE_FIELD(alias);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalRangeTableFuncCol(const RangeTableFuncCol *a, const RangeTableFuncCol *b)
{
  COMPARE_STRING_FIELD(colname);
  COMPARE_NODE_FIELD(typeName);
  COMPARE_SCALAR_FIELD(for_ordinality);
  COMPARE_SCALAR_FIELD(is_not_null);
  COMPARE_NODE_FIELD(colexpr);
  COMPARE_NODE_FIELD(coldefexpr);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalRangeTableSample(const RangeTableSample *a, const RangeTableSample *b)
{
  COMPARE_NODE_FIELD(relation);
  COMPARE_NODE_FIELD(method);
  COMPARE_NODE_FIELD(args);
  COMPARE_NODE_FIELD(repeatable);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalColumnDef(const ColumnDef *a, const ColumnDef *b)
{
  COMPARE_STRING_FIELD(colname);
  COMPARE_NODE_FIELD(typeName);
  COMPARE_STRING_FIELD(compression);
  COMPARE_SCALAR_FIELD(inhcount);
  COMPARE_SCALAR_FIELD(is_local);
  COMPARE_SCALAR_FIELD(is_not_null);
  COMPARE_SCALAR_FIELD(is_from_type);
  COMPARE_SCALAR_FIELD(storage);
  COMPARE_STRING_FIELD(storage_name);
  COMPARE_NODE_FIELD(raw_default);
  COMPARE_NODE_FIELD(cooked_default);
  COMPARE_SCALAR_FIELD(identity);
  COMPARE_NODE_FIELD(identitySequence);
  COMPARE_SCALAR_FIELD(generated);
  COMPARE_NODE_FIELD(collClause);
  COMPARE_SCALAR_FIELD(collOid);
  COMPARE_NODE_FIELD(constraints);
  COMPARE_NODE_FIELD(fdwoptions);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalTableLikeClause(const TableLikeClause *a, const TableLikeClause *b)
{
  COMPARE_NODE_FIELD(relation);
  COMPARE_SCALAR_FIELD(options);
  COMPARE_SCALAR_FIELD(relationOid);

  return true;
}

static bool
_equalIndexElem(const IndexElem *a, const IndexElem *b)
{
  COMPARE_STRING_FIELD(name);
  COMPARE_NODE_FIELD(expr);
  COMPARE_STRING_FIELD(indexcolname);
  COMPARE_NODE_FIELD(collation);
  COMPARE_NODE_FIELD(opclass);
  COMPARE_NODE_FIELD(opclassopts);
  COMPARE_SCALAR_FIELD(ordering);
  COMPARE_SCALAR_FIELD(nulls_ordering);

  return true;
}

static bool
_equalDefElem(const DefElem *a, const DefElem *b)
{
  COMPARE_STRING_FIELD(defnamespace);
  COMPARE_STRING_FIELD(defname);
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(defaction);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonOutput(const JsonOutput *a, const JsonOutput *b)
{
  COMPARE_NODE_FIELD(typeName);
  COMPARE_NODE_FIELD(returning);

  return true;
}

static bool
_equalJsonArgument(const JsonArgument *a, const JsonArgument *b)
{
  COMPARE_NODE_FIELD(val);
  COMPARE_STRING_FIELD(name);

  return true;
}

static bool
_equalJsonFuncExpr(const JsonFuncExpr *a, const JsonFuncExpr *b)
{
  COMPARE_SCALAR_FIELD(op);
  COMPARE_STRING_FIELD(column_name);
  COMPARE_NODE_FIELD(context_item);
  COMPARE_NODE_FIELD(pathspec);
  COMPARE_NODE_FIELD(passing);
  COMPARE_NODE_FIELD(output);
  COMPARE_NODE_FIELD(on_empty);
  COMPARE_NODE_FIELD(on_error);
  COMPARE_SCALAR_FIELD(wrapper);
  COMPARE_SCALAR_FIELD(quotes);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonTablePathSpec(const JsonTablePathSpec *a, const JsonTablePathSpec *b)
{
  COMPARE_NODE_FIELD(string);
  COMPARE_STRING_FIELD(name);
  COMPARE_LOCATION_FIELD(name_location);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonTable(const JsonTable *a, const JsonTable *b)
{
  COMPARE_NODE_FIELD(context_item);
  COMPARE_NODE_FIELD(pathspec);
  COMPARE_NODE_FIELD(passing);
  COMPARE_NODE_FIELD(columns);
  COMPARE_NODE_FIELD(on_error);
  COMPARE_NODE_FIELD(alias);
  COMPARE_SCALAR_FIELD(lateral);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonTableColumn(const JsonTableColumn *a, const JsonTableColumn *b)
{
  COMPARE_SCALAR_FIELD(coltype);
  COMPARE_STRING_FIELD(name);
  COMPARE_NODE_FIELD(typeName);
  COMPARE_NODE_FIELD(pathspec);
  COMPARE_NODE_FIELD(format);
  COMPARE_SCALAR_FIELD(wrapper);
  COMPARE_SCALAR_FIELD(quotes);
  COMPARE_NODE_FIELD(columns);
  COMPARE_NODE_FIELD(on_empty);
  COMPARE_NODE_FIELD(on_error);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonKeyValue(const JsonKeyValue *a, const JsonKeyValue *b)
{
  COMPARE_NODE_FIELD(key);
  COMPARE_NODE_FIELD(value);

  return true;
}

static bool
_equalJsonParseExpr(const JsonParseExpr *a, const JsonParseExpr *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_NODE_FIELD(output);
  COMPARE_SCALAR_FIELD(unique_keys);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonScalarExpr(const JsonScalarExpr *a, const JsonScalarExpr *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_NODE_FIELD(output);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonSerializeExpr(const JsonSerializeExpr *a, const JsonSerializeExpr *b)
{
  COMPARE_NODE_FIELD(expr);
  COMPARE_NODE_FIELD(output);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonObjectConstructor(const JsonObjectConstructor *a, const JsonObjectConstructor *b)
{
  COMPARE_NODE_FIELD(exprs);
  COMPARE_NODE_FIELD(output);
  COMPARE_SCALAR_FIELD(absent_on_null);
  COMPARE_SCALAR_FIELD(unique);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonArrayConstructor(const JsonArrayConstructor *a, const JsonArrayConstructor *b)
{
  COMPARE_NODE_FIELD(exprs);
  COMPARE_NODE_FIELD(output);
  COMPARE_SCALAR_FIELD(absent_on_null);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonArrayQueryConstructor(const JsonArrayQueryConstructor *a, const JsonArrayQueryConstructor *b)
{
  COMPARE_NODE_FIELD(query);
  COMPARE_NODE_FIELD(output);
  COMPARE_NODE_FIELD(format);
  COMPARE_SCALAR_FIELD(absent_on_null);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonAggConstructor(const JsonAggConstructor *a, const JsonAggConstructor *b)
{
  COMPARE_NODE_FIELD(output);
  COMPARE_NODE_FIELD(agg_filter);
  COMPARE_NODE_FIELD(agg_order);
  COMPARE_NODE_FIELD(over);
  COMPARE_LOCATION_FIELD(location);

  return true;
}

static bool
_equalJsonObjectAgg(const JsonObjectAgg *a, const JsonObjectAgg *b)
{
  COMPARE_NODE_FIELD(constructor);
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(absent_on_null);
  COMPARE_SCALAR_FIELD(unique);

  return true;
}

static bool
_equalJsonArrayAgg(const JsonArrayAgg *a, const JsonArrayAgg *b)
{
  COMPARE_NODE_FIELD(constructor);
  COMPARE_NODE_FIELD(arg);
  COMPARE_SCALAR_FIELD(absent_on_null);

  return true;
}

/*****************************************************************************/